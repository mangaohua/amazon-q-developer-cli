import { file_fig as file } from "@aws/amazon-q-developer-cli-proto/fig";
import { CodeBlockWriter, IndentationText, Project } from "ts-morph";
import { readFileSync } from "node:fs";
import { join, dirname } from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

/* eslint-enable import/no-extraneous-dependencies */
const capitalizeFirstLetter = (str: string) =>
  str.charAt(0).toUpperCase() + str.slice(1);

const lowercaseFirstLetter = (str: string) =>
  str.charAt(0).toLowerCase() + str.slice(1);

const normalize = (type: string): string => {
  let normalized = type;
  if (type.endsWith("Request")) {
    normalized = type.replace("Request", "");
  } else if (type.endsWith("Response")) {
    normalized = type.replace("Response", "");
  }

  return capitalizeFirstLetter(normalized);
};

const getSubmessageTypes = (interfaceName: string) => {
  const message = file.messages.find(
    (message) => message.name === interfaceName,
  );
  return (
    message?.fields.map((type) => type.message?.name!).filter(Boolean) ?? []
  );
};

const writeGenericSendRequestWithResponseFunction = (
  writer: CodeBlockWriter,
  endpoint: string,
) => {
  const lowercasedEndpoint = lowercaseFirstLetter(endpoint);

  const template = `export async function send${endpoint}Request(
request: Omit<${endpoint}Request, "$typeName" | "$unknown">
): Promise<${endpoint}Response> {
  return new Promise((resolve, reject) => {
    sendMessage(
      { case: "${lowercasedEndpoint}Request", value: create(${endpoint}RequestSchema, request) },
      (response) => {
        switch (response?.case) {
          case "${lowercasedEndpoint}Response":
            resolve(response.value);
            break;
          case "error":
            reject(Error(response.value));
            break;
          default:
            reject(
              Error(
                  \`Invalid response '\${response?.case}' for '${endpoint}Request'\`
              )
            );
        }
      }
    );
  });
}`;

  writer.writeLine(template).blankLine();
};

const writeGenericSendRequestFunction = (
  writer: CodeBlockWriter,
  endpoint: string,
) => {
  const lowercasedEndpoint = lowercaseFirstLetter(endpoint);

  const template = `export async function send${endpoint}Request(
  request: Omit<${endpoint}Request, "$typeName" | "$unknown">
): Promise<void> {
  return new Promise((resolve, reject) => {
    sendMessage(
      { case: "${lowercasedEndpoint}Request", value: create(${endpoint}RequestSchema, request) },
      (response) => {
        switch (response?.case) {
          case "success":
            resolve();
            break;
          case "error":
            reject(Error(response.value));
            break;
          default:
            reject(
              Error(
                \`Invalid response '\${response?.case}' for '${endpoint}Request'\`
              )
            );
        }
      }
    );
  });
}`;
  writer.writeLine(template).blankLine();
};

const project = new Project({
  manipulationSettings: {
    indentationText: IndentationText.TwoSpaces,
  },
});

project.addSourceFilesAtPaths(join(__dirname, "../src/*.ts"));

const requestTypes = getSubmessageTypes("ClientOriginatedMessage");
const responseTypes = getSubmessageTypes("ServerOriginatedMessage").filter(
  (type) => type.includes("Response"),
);

const [requestsWithMatchingResponses, otherRequests] = requestTypes
  .filter((request) => request !== "notificationRequest")
  .reduce(
    (result, request) => {
      const [matchingResponse, other] = result;

      const endpoint = normalize(request);

      console.log(endpoint, requestTypes);

      if (responseTypes.indexOf(`${endpoint}Response`) !== -1) {
        return [matchingResponse.concat([request]), other];
      }
      return [matchingResponse, other.concat([request])];
    },
    [[] as string[], [] as string[]],
  );

console.log(requestsWithMatchingResponses, otherRequests);

const protoVersion = JSON.parse(
  readFileSync(join(__dirname, "../../../proto/package.json"), "utf8"),
).version;

const sourceFile = project.createSourceFile(
  join(__dirname, "../src/requests.ts"),
  (writer) => {
    writer.writeLine(
      `/* Autogenerated by generate-requests.ts for proto v${protoVersion}`,
    );
    writer.writeLine(
      ` * Do not edit directly! Instead run 'npm run generate-requests' in typescript-api-bindings`,
    );
    writer.writeLine(` */`).blankLine();

    const responses = requestsWithMatchingResponses.map((request) =>
      request.replace("Request", "Response"),
    );
    const requestSchemas = requestsWithMatchingResponses.map(
      (s) => `${s}Schema`,
    );
    const otherRequestSchemas = otherRequests.map((s) => `${s}Schema`);
    const imports = [
      requestsWithMatchingResponses,
      responses,
      otherRequests,
      requestSchemas,
      otherRequestSchemas,
    ]
      .flat()
      .sort()
      .map(capitalizeFirstLetter);
    writer.writeLine(
      `import { \n${imports.join(",\n")}\n } from "@aws/amazon-q-developer-cli-proto/fig";`,
    );
    writer
      .writeLine(
        [
          'import { sendMessage } from "./core.js";',
          'import { create } from "@bufbuild/protobuf";',
        ].join("\n"),
      )
      .blankLine();

    requestsWithMatchingResponses.forEach((request) =>
      writeGenericSendRequestWithResponseFunction(writer, normalize(request)),
    );
    otherRequests.forEach((request) =>
      writeGenericSendRequestFunction(writer, normalize(request)),
    );
  },
  { overwrite: true },
);

sourceFile.formatText();
sourceFile.saveSync();
